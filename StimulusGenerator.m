function varargout = StimulusGenerator(varargin)
% STIMULUSGENERATOR MATLAB code for StimulusGenerator.fig
%      STIMULUSGENERATOR, by itself, creates a new STIMULUSGENERATOR or raises the existing
%      singleton*.
%
%      H = STIMULUSGENERATOR returns the handle to a new STIMULUSGENERATOR or the handle to
%      the existing singleton*.
%
%      STIMULUSGENERATOR('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in STIMULUSGENERATOR.M with the given input arguments.
%
%      STIMULUSGENERATOR('Property','Value',...) creates a new STIMULUSGENERATOR or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before StimulusGenerator_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to StimulusGenerator_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help StimulusGenerator

% Last Modified by GUIDE v2.5 17-Feb-2016 11:46:35

                            % Initialization code generated by GUIDE - DO NOT EDIT
                            gui_Singleton = 1;
                            gui_State = struct('gui_Name',       mfilename, ...
                                               'gui_Singleton',  gui_Singleton, ...
                                               'gui_OpeningFcn', @StimulusGenerator_OpeningFcn, ...
                                               'gui_OutputFcn',  @StimulusGenerator_OutputFcn, ...
                                               'gui_LayoutFcn',  [] , ...
                                               'gui_Callback',   []);
                            if nargin && ischar(varargin{1})
                                gui_State.gui_Callback = str2func(varargin{1});
                            end

                            if nargout
                                [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
                            else
                                gui_mainfcn(gui_State, varargin{:});
                            end
                            % End initialization code - DO NOT EDIT


% --- Executes just before StimulusGenerator is made visible.
function StimulusGenerator_OpeningFcn(hObject, ~, handles, varargin)
    % Choose default command line output for StimulusGenerator
    handles.output = hObject;

    % variables will be passed between functions through handles struct
    handles.experimentInfo.experimentNumber=1;

    %%% Set Enable state and default parameters for each stimType
    %%% Legend:
    %%% 1='Single Bar'
    %%% 2='Double Bar'
    %%% 3='Sin-Wave Gratings'
    %%% 4='Square-Wave Gratings'
    %%% 5='Checkerboards'
    %%% 6='Full-Field Flash'
    %%% 7='Size Mapping'
    handles.guiInfo.paramPrefixes={'orient','width','speed','accel','contrast','length','addWidth','addX','addY'};
    handles.guiInfo.paramSuffixes={'Units','First','Vary','Last','Num','Range'};
    handles.guiInfo.paramHasUnits=[0,1,1,1,0,0];
    handles.guiInfo.defaultParametersByStimType{1}=...  % Single Bar
        [NaN, 180, 1, 315, 8;...                      % orientation [units, first, vary, last, num]
        2, 5, 1, 3, 1;...                           % size
        3, 14, 1, 14, 1;...                         % speed
        NaN, 0, 1, 0, 1;...                         % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{2}=...  % Double Bar
        [NaN, 0, 2, 315, 8;...                      % orientation [units, first, vary, last, num]
        2, 3, 1, 3, 1;...                           % size
        3, 14, 1, 14, 1;...                         % speed
        NaN, 0, 1, 0, 1;...                         % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{3}=...  % Sin-Wave Gratings
        [NaN, 0, 2, 315, 8;...                      % orientation [units, first, vary, last, num]
        1, .5, 1, .5, 1;...                         % size
        Inf, 1, 1, 1, 1;...                           % speed
        Inf, 0, 1, 0, 1;...                           % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{4}=...  % Square-Wave Gratings
        [NaN, 0, 2, 315, 8;...                      % orientation [units, first, vary, last, num]
        1, .5, 1, .5, 1;...                         % size
        Inf, 1, 1, 1, 1;...                           % speed
        Inf, 0, 1, 0, 1;...                           % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{5}=...  % Checkerboards
        [NaN, 0, 1, 0, 1;...                        % orientation [units, first, vary, last, num]
        2, 3, 1, 3, 1;...                           % size
        Inf, 3, 1, 3, 1;...                        % speed
        NaN, 0, 1, 0, 1;...                         % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{6}=...  % Full-Field Flicker
        [NaN, 0, 1, 0, 1;...                        % orientation [units, first, vary, last, num]
        2, 3, 1, 3, 1;...                           % size
        Inf, 3, 1, 3, 1;...                        % speed
        NaN, 0, 1, 0, 1;...                         % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 0, 1, 0, 1;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY
    handles.guiInfo.defaultParametersByStimType{7}=...  % Size Mapping
        [NaN, 0, 1, 0, 1;...                        % orientation [units, first, vary, last, num]
        1, 0.5, 1, 0.5, 1;...                       % size
        Inf, 1, 1, 1, 1;...                           % speed
        Inf, 0, 1, 0, 1;...                         % acceleration
        NaN, 1, 1, 1, 1;...                         % contrast
        NaN, 1, 2, 6, 6;...                         % length
        1, 5, 1, 5, 1;...                           % addWidth
        NaN, 20, 1, 20, 1;...                       % addX
        NaN, 10, 1, 10, 1];                         % addY

    handles.guiInfo.gratingsIndices={3,4,5,6,7};
    
    handles.guiInfo.popups={'stimType',...
        'orientVary',...
        'widthUnits','widthVary',...
        'speedUnits','speedVary',...
        'accelUnits','accelVary',...
        'contrastVary',...
        'lengthVary',...
        'addWidthUnits','addWidthVary',...
        'addXVary',...
        'addYVary'};
    handles.guiInfo.edits={'orientFirst','orientLast','orientNum',...
        'widthFirst','widthLast','widthNum',...
        'speedFirst','speedLast','speedNum',...
        'accelFirst','accelLast','accelNum',...
        'contrastFirst','contrastLast','contrastNum',...
        'lengthFirst','lengthLast','lengthNum',...
        'addWidthFirst','addWidthLast','addWidthNum'...
        'addXFirst','addXLast','addXNum',...
        'addYFirst','addYLast','addYNum',...
        'screenNum','screenDist','screenHz','screenGamma',...
        'screenXpix','screenYpix','screenXcm','screenYcm',...
        'locationUp','locationRight',...
        'gazeUp','gazeRight',...
        'rfUp','rfRight',...
        'movieScale','movieHz',...
        'checkDeg','checkHz',...
        'stimDuration','waitDuration','numberTrials','numberIterations',...
        'movieScale','movieHz'};
    handles.guiInfo.checkboxes={'runMovie','randomOrder','addBlank',...
        'frameIndicator','adjustSpherically','transverseBars',...
        'syncTDT','checkeredFlicker','intrinsicImaging'};
    handles.guiInfo.textdisplays={'orientRange','widthRange','speedRange',...
        'accelRange','contrastRange','lengthRange',...
        'addWidthRange','addXRange','addYRange'};
    
    handles.guiInfo.keyCodes.escape=41;
    handles.guiInfo.keyCodes.up=82;
    handles.guiInfo.keyCodes.right=79;
    handles.guiInfo.keyCodes.down=81;
    handles.guiInfo.keyCodes.left=80;
    handles.guiInfo.keyCodes.shift=225;
    handles.guiInfo.keyCodes.one=30;
    handles.guiInfo.keyCodes.two=31;
    handles.guiInfo.keyCodes.zed=29;
    
    handles.screenInfo.windowPtr=[];
    handles.stimulusInfo=[];
    handles.experimentInfo.rerun=0;
    handles.experimentInfo.texLoaded=0;
    
    % Update handles structure
    guidata(handles.output, handles);
   
% --- Executes right after respect fields are changed
function stimType_Callback(hObject, eventdata, handles)
    stimType = get(hObject,'Value');
    %%% set parameters to default values appropriate for stimulus type and
    switch stimType
        case handles.guiInfo.gratingsIndices % gratings
            set(handles.stimDuration,'Enable','on');
        otherwise % not grating
            set(handles.stimDuration,'Enable','off');
    end
    
    for pindex=1:6
        for sindex=1:5
            pTag=[handles.guiInfo.paramPrefixes{pindex},handles.guiInfo.paramSuffixes{sindex}];
            pValue=handles.guiInfo.defaultParametersByStimType{stimType}(pindex,sindex);
            switch get(handles.(pTag),'Style')
                case 'popupmenu'
                    if isnan(pValue) || (isinf(pValue) && sign(pValue)==1)
                        set(handles.(pTag),'Value',1,'Enable','off');
                    elseif isinf(pValue) && sign(pValue)==-1
                        set(handles.(pTag),'Value',get(handles.(pTag),'Max'),'Enable','off');
                    else
                        set(handles.(pTag),'Value',pValue,'Enable','on');
                    end
                case 'edit'
                    set(handles.(pTag),'String',num2str(pValue),'Enable','on');
                    if sindex>2 && get(handles.([handles.guiInfo.paramPrefixes{pindex},'Vary']),'Value')==1
                        set(handles.(pTag),'Enable','off');
                    elseif isequal(get(handles.([handles.guiInfo.paramPrefixes{pindex},'Units']),'Style'),'popupmenu')
                        if isnan(handles.guiInfo.defaultParametersByStimType{stimType}(pindex,1))
                            set(handles.(pTag),'Enable','off');
                        end
                    end
            end
        end
    end
    set(handles.('addWidthUnits'),'Value',1,'Enable','on');
    for sindex=2:5
        set(handles.(['addWidth',handles.guiInfo.paramSuffixes{sindex}]),'Enable','off');
        set(handles.(['addX',handles.guiInfo.paramSuffixes{sindex}]),'Enable','off');
        set(handles.(['addY',handles.guiInfo.paramSuffixes{sindex}]),'Enable','off');
    end
    
    handles.stimulusInfo.stimType=stimType;
    allCallbacks(hObject,eventdata,handles);
    handles=guidata(handles.output);
    guidata(handles.output, handles);


function allCallbacks(hObject,eventdata,handles)
    if ~isfield(handles.stimulusInfo,'screen') || ~isfield(handles.screenInfo,'Hz')
        screenGamma_Callback(handles.screenGamma,eventdata,handles);
        handles=guidata(handles.output);
        screenNum_Callback(handles.screenNum,eventdata,handles);
        handles=guidata(handles.output);
    end
    screenDist_Callback(handles.screenDist,eventdata,handles);
    handles=guidata(handles.output);
    orientCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    contrastCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    lengthCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    adjustSpherically_Callback(handles.adjustSpherically,eventdata,handles);
    handles=guidata(handles.output);
    addCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    rfUp_Callback(handles.rfUp,eventdata,handles);
    handles=guidata(handles.output);
    rfRight_Callback(handles.rfRight,eventdata,handles);
    handles=guidata(handles.output);
    syncTDT_Callback(handles.syncTDT,eventdata,handles);
    handles=guidata(handles.output);
    runMovie_Callback(handles.runMovie,eventdata,handles);
    handles=guidata(handles.output);
    movieScale_Callback(handles.movieScale,eventdata,handles);
    handles=guidata(handles.output);
    movieHz_Callback(handles.movieHz,eventdata,handles);
    handles=guidata(handles.output);
    waitDuration_Callback(handles.waitDuration,eventdata,handles);
    handles=guidata(handles.output);
    randomOrder_Callback(handles.randomOrder,eventdata,handles);
    handles=guidata(handles.output);
    addBlank_Callback(handles.addBlank,eventdata,handles);
    handles=guidata(handles.output);
    adjustSpherically_Callback(handles.adjustSpherically,eventdata,handles);
    handles=guidata(handles.output);
    transverseBars_Callback(handles.transverseBars, eventdata, handles);
    handles=guidata(handles.output);
    frameIndicator_Callback(handles.frameIndicator, eventdata, handles);
	handles=guidata(handles.output);
    checkeredFlicker_Callback(handles.checkeredFlicker, eventdata, handles);
    handles=guidata(handles.output);
    intrinsicImaging_Callback(handles.intrinsicImaging, eventdata, handles);
    handles=guidata(handles.output);
    checkDeg_Callback(handles.checkDeg,eventdata,handles);
    handles=guidata(handles.output);
    checkHz_Callback(handles.checkHz,eventdata,handles);
    handles=guidata(handles.output);
    numberTrials_Callback(handles.numberTrials,eventdata,handles);
    handles=guidata(handles.output);
    numberIterations_Callback(handles.numberIterations,eventdata,handles);
    handles=guidata(handles.output);
    experimentalNotes_Callback(handles.experimentalNotes,eventdata,handles);
    handles=guidata(handles.output);
    guidata(handles.output,handles);
    
    
function orientCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.orientVary,'Value');
    
    switch vary
        case {2,3}
            set(handles.orientLast,'Enable','on');
            set(handles.orientNum,'Enable','on');
        otherwise
            set(handles.orientLast,'Enable','off');
            set(handles.orientNum,'Enable','off');
    end
    
    first = str2double(get(handles.orientFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first)
        first=handles.guiInfo.defaultParametersByStimType{stimType}(1,2);
    end
    set(handles.orientFirst,'String',num2str(first));

    last = str2double(get(handles.orientLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last)
        last=handles.guiInfo.defaultParametersByStimType{stimType}(1,3);
    end
    set(handles.orientLast,'String',num2str(last));

    num = round(str2double(get(handles.orientNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.orientNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.orientations=first;
        case 2
            handles.stimulusInfo.orientations=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.orientations=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.orientRange,'String',mat2str(handles.stimulusInfo.orientations));
    handles.experimentInfo.rerun=0;
    guidata(handles.output, handles);

function widthCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.widthVary,'Value');

    switch vary
        case {2,3}
            set(handles.widthLast,'Enable','on');
            set(handles.widthNum,'Enable','on');
        otherwise
            set(handles.widthLast,'Enable','off');
            set(handles.widthNum,'Enable','off');
    end
    
    first = str2double(get(handles.widthFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first) || first<0
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.widthFirst,'String',num2str(first));

    last = str2double(get(handles.widthLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last) || last<0
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.widthLast,'String',num2str(last));

    num = round(str2double(get(handles.widthNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.widthNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.widths=first;
        case 2
            handles.stimulusInfo.widths=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.widths=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.widthRange,'String',mat2str(handles.stimulusInfo.widths));
    handles.experimentInfo.rerun=0;
    guidata(handles.output, handles);

function speedCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.speedVary,'Value');
    units = get(handles.speedUnits,'Value');
    switch vary
        case {2,3}
            set(handles.speedLast,'Enable','on');
            set(handles.speedNum,'Enable','on');
        otherwise
            set(handles.speedLast,'Enable','off');
            set(handles.speedNum,'Enable','off');
    end
    
    first = str2double(get(handles.speedFirst,'String'));
    if (units==3 || vary==3) && first<=0
        first=1;
    elseif isempty(first) || first<0
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.speedFirst,'String',num2str(first));

    last = str2double(get(handles.speedLast,'String'));
    if (units==3 || vary==3) && last<=0
        last=1;
    elseif isempty(last) || last<0
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.speedLast,'String',num2str(last));

    num = round(str2double(get(handles.speedNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.speedNum,'String',num2str(num));
    switch vary
        case 1
            handles.stimulusInfo.speeds=first;
        case 2
            handles.stimulusInfo.speeds=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.speeds=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.speedRange,'String',mat2str(handles.stimulusInfo.speeds));
    handles.experimentInfo.rerun=0;
    guidata(handles.output, handles);
  
function accelCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.accelVary,'Value');

    switch vary
        case {2,3}
            set(handles.accelLast,'Enable','on');
            set(handles.accelNum,'Enable','on');
        otherwise
            set(handles.accelLast,'Enable','off');
            set(handles.accelNum,'Enable','off');
    end
    
    first = str2double(get(handles.accelFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first)
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.accelFirst,'String',num2str(first));

    last = str2double(get(handles.accelLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last)
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.accelLast,'String',num2str(last));

    num = round(str2double(get(handles.accelNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.accelNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.accelerations=first;
        case 2
            handles.stimulusInfo.accelerations=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.accelerations=fliplr(logspace(log10(last),log10(first),num));
    end
    if get(handles.speedUnits,'Value')==3
        set(handles.accelRange,'String','acceleration undefined');
    else
        set(handles.accelRange,'String',mat2str(handles.stimulusInfo.accelerations));
    end
    
    if get(handles.speedUnits,'Value')==3
        set(handles.accelFirst,'Enable','off');
        set(handles.accelVary,'Enable','off');
        set(handles.accelLast,'Enable','off');
        set(handles.accelNum,'Enable','off');
    end
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 

function contrastCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.contrastVary,'Value');

    switch vary
        case {2,3}
            set(handles.contrastLast,'Enable','on');
            set(handles.contrastNum,'Enable','on');
        otherwise
            set(handles.contrastLast,'Enable','off');
            set(handles.contrastNum,'Enable','off');
    end
    
    first = str2double(get(handles.contrastFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first) || abs(first)>1
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.contrastFirst,'String',num2str(first));

    last = str2double(get(handles.contrastLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last) || abs(last)>1
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.contrastLast,'String',num2str(last));

    num = round(str2double(get(handles.contrastNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.contrastNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.contrasts=first;
        case 2
            handles.stimulusInfo.contrasts=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.contrasts=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.contrastRange,'String',mat2str(handles.stimulusInfo.contrasts));
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 

function lengthCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.lengthVary,'Value');

    switch vary
        case {2,3}
            set(handles.lengthLast,'Enable','on');
            set(handles.lengthNum,'Enable','on');
        otherwise
            set(handles.lengthLast,'Enable','off');
            set(handles.lengthNum,'Enable','off');
    end
    
    first = str2double(get(handles.lengthFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first) || first<0
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.lengthFirst,'String',num2str(first));

    last = str2double(get(handles.lengthLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last) || last<0
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.lengthLast,'String',num2str(last));

    num = round(str2double(get(handles.lengthNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.lengthNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.lengths=first;
        case 2
            handles.stimulusInfo.lengths=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.lengths=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.lengthRange,'String',mat2str(handles.stimulusInfo.lengths));
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
    
function addCallback(hObject,eventdata,handles)
    addType = get(handles.addWidthUnits,'Value');
    handles.stimulusInfo.addType=addType;
    if addType==1
        for pindex=7:9
            for sindex=2:5
                pTag=[handles.guiInfo.paramPrefixes{pindex},handles.guiInfo.paramSuffixes{sindex}];
                set(handles.(pTag),'Enable','Off')
            end
        end
        handles.stimulusInfo.addWidths=0;
        handles.stimulusInfo.addXs=0;
        handles.stimulusInfo.addYs=0;
    else
        for pindex=7:9
            for sindex=2:3
                pTag=[handles.guiInfo.paramPrefixes{pindex},handles.guiInfo.paramSuffixes{sindex}];
                set(handles.(pTag),'Enable','On')
            end
        end
        addWidthCallback(hObject,eventdata,handles);
        handles=guidata(handles.output);
        addXCallback(hObject,eventdata,handles);
        handles=guidata(handles.output);
        addYCallback(hObject,eventdata,handles);
        handles=guidata(handles.output);
    end
    guidata(handles.output,handles) 

function addWidthCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.addWidthVary,'Value');

    switch vary
        case {2,3}
            set(handles.addWidthLast,'Enable','on');
            set(handles.addWidthNum,'Enable','on');
        otherwise
            set(handles.addWidthLast,'Enable','off');
            set(handles.addWidthNum,'Enable','off');
    end
    
    first = str2double(get(handles.addWidthFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first) || first<0
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.addWidthFirst,'String',num2str(first));

    last = str2double(get(handles.addWidthLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last) || last<0
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.addWidthLast,'String',num2str(last));

    num = round(str2double(get(handles.addWidthNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.addWidthNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.addWidths=first;
        case 2
            handles.stimulusInfo.addWidths=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.addWidths=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.addWidthRange,'String',mat2str(handles.stimulusInfo.addWidths));
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
    
function addXCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.addXVary,'Value');

    switch vary
        case {2,3}
            set(handles.addXLast,'Enable','on');
            set(handles.addXNum,'Enable','on');
        otherwise
            set(handles.addXLast,'Enable','off');
            set(handles.addXNum,'Enable','off');
    end
    
    first = str2double(get(handles.addXFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first)
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.addXFirst,'String',num2str(first));

    last = str2double(get(handles.addXLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last)
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.addXLast,'String',num2str(last));

    num = round(str2double(get(handles.addXNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.addXNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.addXs=first;
        case 2
            handles.stimulusInfo.addXs=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.addXs=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.addXRange,'String',mat2str(handles.stimulusInfo.addXs));
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
    
function addYCallback(hObject,~,handles)
    stimType = get(handles.stimType,'Value');
    vary = get(handles.addYVary,'Value');

    switch vary
        case {2,3}
            set(handles.addYLast,'Enable','on');
            set(handles.addYNum,'Enable','on');
        otherwise
            set(handles.addYLast,'Enable','off');
            set(handles.addYNum,'Enable','off');
    end
    
    first = str2double(get(handles.addYFirst,'String'));
    if vary==3 && first<=0
        first=1;
    elseif isempty(first)
        first=handles.guiInfo.defaultParametersByStimType{stimType}(2,2);
    end
    set(handles.addYFirst,'String',num2str(first));

    last = str2double(get(handles.addYLast,'String'));
    if vary==3 && last<=0
        last=1;
    elseif isempty(last)
        last=handles.guiInfo.defaultParametersByStimType{stimType}(2,3);
    end
    set(handles.addYLast,'String',num2str(last));

    num = round(str2double(get(handles.addYNum,'String')));
    if num < 1
        num=1;
    end
    set(handles.addYNum,'String',num2str(num));

    switch vary
        case 1
            handles.stimulusInfo.addYs=first;
        case 2
            handles.stimulusInfo.addYs=fliplr(linspace(last,first,num));
        case 3
            handles.stimulusInfo.addYs=fliplr(logspace(log10(last),log10(first),num));
    end
    set(handles.addYRange,'String',mat2str(handles.stimulusInfo.addYs));
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 

function orientFirst_Callback(hObject, eventdata, handles)
    orientCallback(hObject,eventdata,handles);
function orientVary_Callback(hObject, eventdata, handles)
    orientCallback(hObject,eventdata,handles);
function orientLast_Callback(hObject, eventdata, handles)
    orientCallback(hObject,eventdata,handles);
function orientNum_Callback(hObject, eventdata, handles)
    orientCallback(hObject,eventdata,handles);

function widthUnits_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);

function widthFirst_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function widthVary_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function widthLast_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function widthNum_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);

function speedUnits_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function speedFirst_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function speedVary_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function speedLast_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function speedNum_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
   
function accelUnits_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function accelFirst_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function accelVary_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function accelLast_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
function accelNum_Callback(~, eventdata, handles)
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
    
function contrastFirst_Callback(hObject, eventdata, handles)
    contrastCallback(hObject,eventdata,handles);
function contrastVary_Callback(hObject, eventdata, handles)
    contrastCallback(hObject,eventdata,handles);
function contrastLast_Callback(hObject, eventdata, handles)
    contrastCallback(hObject,eventdata,handles);
function contrastNum_Callback(hObject, eventdata, handles)
    contrastCallback(hObject,eventdata,handles);
    
function lengthFirst_Callback(hObject, eventdata, handles)
    lengthCallback(hObject,eventdata,handles);
function lengthVary_Callback(hObject, eventdata, handles)
    lengthCallback(hObject,eventdata,handles);
function lengthLast_Callback(hObject, eventdata, handles)
    lengthCallback(hObject,eventdata,handles);
function lengthNum_Callback(hObject, eventdata, handles)
    lengthCallback(hObject,eventdata,handles);
    
function addWidthUnits_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addWidthFirst_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addWidthVary_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addWidthLast_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addWidthNum_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);

function addXFirst_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addXVary_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addXLast_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addXNum_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
    
function addYFirst_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addYVary_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addYLast_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
function addYNum_Callback(hObject, eventdata, handles)
    addCallback(hObject,eventdata,handles);
    
    
function screenNum_Callback(hObject, eventdata, handles)
    num=round(str2double(get(hObject,'String')));
    screens=Screen('Screens');
    if isempty(num) || ~ismember(num,screens)
        num=max(screens);
    end
    set(hObject,'String',num2str(num));
    handles.screenInfo.num=num;
    screenHz_Callback(handles.screenHz,eventdata,handles);
    handles=guidata(handles.output);
    screenXpix_Callback(handles.screenXpix,eventdata,handles);
    handles=guidata(handles.output);
    screenYpix_Callback(handles.screenYpix,eventdata,handles);
    handles=guidata(handles.output);
    guidata(handles.output,handles) 
    
function screenDist_Callback(hObject, eventdata, handles)
    if ~isfield(handles.screenInfo,'cm')
        try
            screencm=Screen('DisplaySize',handles.screenInfo.num)/1000;
            xcm=screencm(1);
            ycm=screencm(2);
            set(handles.screenXcm,'String',num2str(xcm));
            set(handles.screenYcm,'String',num2str(ycm));
        catch
        end
    end
    
    xcm=str2double(get(handles.screenXcm,'String'));
    if isempty(xcm)
        xcm=42.4;
    end

    ycm=str2double(get(handles.screenYcm,'String'));
    if isempty(ycm)
        ycm=28.3;
    end
    
    set(handles.screenXcm,'String',num2str(xcm));
    handles.screenInfo.cm(1)=xcm;
    
    set(handles.screenYcm,'String',num2str(ycm));
    handles.screenInfo.cm(2)=ycm;
    
    gaze_up=str2double(get(handles.gazeUp,'String'));
    if isempty(gaze_up)
        gaze_up=0.5*ycm;
    end
    set(handles.gazeUp,'String',num2str(gaze_up));
    handles.gazeInfo.cm(2)=gaze_up;
    handles.gazeInfo.frac(2)=gaze_up/ycm;
    
    gaze_right=str2double(get(handles.gazeRight,'String'));
    if isempty(gaze_right)% || gaze_right<0 || gaze_right>1
        gaze_right=0;
    end
    set(handles.gazeRight,'String',num2str(gaze_right));
    handles.gazeInfo.cm(1)=gaze_right;
    handles.gazeInfo.frac(1)=gaze_right/xcm;

    screendist=str2double(get(hObject,'String'));
    if isempty(screendist)
        screendist=25;
    end
    set(hObject,'String',num2str(screendist));
    
    handles.screenInfo.distance=screendist;
    left=[-handles.gazeInfo.cm(1),0,screendist];
    right=[handles.screenInfo.cm(1)-handles.gazeInfo.cm(1),0,screendist];
    bottom=[0,-handles.gazeInfo.cm(2),screendist];
    top=[0,handles.screenInfo.cm(2)-handles.gazeInfo.cm(2),screendist];
    handles.screenInfo.deg(1)=vecangle(left,right);
    handles.screenInfo.deg(2)=vecangle(bottom,top);
    set(handles.screenXdeg,'String',num2str(handles.screenInfo.deg(1)));
    set(handles.screenYdeg,'String',num2str(handles.screenInfo.deg(2)));
    stimDuration_Callback(handles.stimDuration,eventdata,handles);
    handles=guidata(handles.output);
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
function screenHz_Callback(hObject, ~, handles)
    matchScreens(handles);
    handles=guidata(handles.output);
    screenHz=1/Screen('GetFlipInterval',handles.screenInfo.windowPtr);
    set(hObject,'String',screenHz);
    handles.screenInfo.Hz=screenHz;
    set(hObject,'Enable','off');
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
    

function screenGamma_Callback(hObject, ~, handles)
    screenGamma=str2double(get(hObject,'String'));
    if isempty(screenGamma)
        screenGamma=0;
    end
    set(hObject,'String',num2str(screenGamma));
    handles.screenInfo.gamma=screenGamma; 
    guidata(handles.output,handles) 
    
function numberTrials_Callback(hObject, ~, handles)
    numberTrials=str2double(get(hObject,'String'));
    if isempty(numberTrials)
        numberTrials=0;
    end
    set(hObject,'String',num2str(numberTrials));
    handles.stimulusInfo.numberTrials=numberTrials; 
    guidata(handles.output,handles)    

function numberIterations_Callback(hObject, ~, handles)
    numberIters=str2double(get(hObject,'String'));
    if isempty(numberIters)
        numberIters=0;
    end
    set(hObject,'String',num2str(numberIters));
    handles.stimulusInfo.numberIters=numberIters; 
    guidata(handles.output,handles)    

function checkHz_Callback(hObject, ~, handles)
    checkHz=str2double(get(hObject,'String'));
    if isempty(checkHz) || checkHz<=0
        checkHz=10;
    end
    set(hObject,'String',num2str(checkHz));
    handles.stimulusInfo.checkHz=checkHz; 
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
    
function screenXpix_Callback(hObject, ~, handles)
    rect = Screen(handles.screenInfo.num,'Rect');
    handles.screenInfo.pix(1)=rect(3);
    set(hObject,'String',num2str(rect(3)));
    set(hObject,'Enable','off');
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
function screenYpix_Callback(hObject, ~, handles)
    rect = Screen(handles.screenInfo.num,'Rect');
    handles.screenInfo.pix(2)=rect(4);
    set(hObject,'String',num2str(rect(4)));
    set(hObject,'Enable','off');
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 
function screenXcm_Callback(~, eventdata, handles)
    screenDist_Callback(handles.screenDist, eventdata, handles)
function screenYcm_Callback(~, eventdata, handles)
    screenDist_Callback(handles.screenDist, eventdata, handles)    
function gazeRight_Callback(~, eventdata, handles)
    screenDist_Callback(handles.screenDist, eventdata, handles)
function gazeUp_Callback(~, eventdata, handles)
    screenDist_Callback(handles.screenDist, eventdata, handles)
function rfUp_Callback(hObject, ~, handles)
    rfUp=str2double(get(hObject,'String'));
    if isempty(rfUp)
        rfUp=0;
    end
    set(hObject,'String',num2str(rfUp));
    
    pixelsX=handles.screenInfo.pix(1);
    pixelsY=handles.screenInfo.pix(2);
    cmX=handles.screenInfo.pix(1);
    cmY=handles.screenInfo.pix(2);
    screenDistance=handles.screenInfo.distance;
    gazeUp=handles.gazeInfo.frac(2);
    gazeRight=handles.gazeInfo.frac(1);
                
    [coordY,coordX]=meshgrid(1/pixelsY:1/pixelsY:1,1/pixelsX:1/pixelsX:1); % as fraction of screen
    coordX=coordX-gazeRight;
    coordY=coordY-gazeUp;
    if handles.stimulusInfo.adjustSpherically
        coordX=coordX*cmX; % in cm
        coordY=coordY*cmY; % in cm
        Azimuth=atand(coordX./screenDistance); % degrees in direction of motion
        Altitude=acosd(coordY./sqrt(screenDistance.^2+coordX.^2+coordY.^2))-90;
    else
        Azimuth=coordX*handles.screenInfo.deg(1); % in degrees
        Altitude=coordY*handles.screenInfo.deg(2); % in degrees
    end    
    
    handles.stimulusInfo.rf.deg(2)=rfUp; 
    guidata(handles.output,handles) 
function rfRight_Callback(hObject, ~, handles)
    rfRight=str2double(get(hObject,'String'));
    if isempty(rfRight)
        rfRight=0;
    end
    set(hObject,'String',num2str(rfRight));
    handles.stimulusInfo.rf.deg(1)=rfRight;
    guidata(handles.output,handles) 
function findLocation_Callback(hObject, eventdata, handles)
try        
    if ~isfield(handles.parameters,'keyCodes')
        getKeyCodes_Callback(handles.getKeyCodes,eventdata,handles);
        handles=guidata(handles.output);
    end

    x=handles.stimulusInfo.rf.deg(1);
    y=handles.stimulusInfo.rf.deg(2);
    find_hotspot=0;
    [yCoord,xCoord]=meshgrid(1:handles.screenInfo.pix(2),1:handles.screenInfo.pix(1));
    xCoord=xCoord-handles.screenInfo.pix(1).*handles.gazeInfo.right;
    yCoord=yCoord-handles.screenInfo.pix(2).*handles.gazeInfo.up;
    frame=zeros(handles.screenInfo.pix(1),handles.screenInfo.pix(2));
    radius=100;
    binary=0;
    matchScreens(handles);
    handles=guidata(handles.output);
    vbl = Screen('Flip',w);
    while ~find_hotspot
        binary=~binary;
        frame(:)=greyIndex;
        if binary
            frame(sqrt((xCoord-x).^2+(yCoord-y).^2)<radius)=white;
        else
            frame(sqrt((xCoord-x).^2+(yCoord-y).^2)<radius)=black;
        end
        tex=Screen('MakeTexture',w,frame');
        Screen('DrawTexture',w, tex);
        vbl = Screen('Flip',w, vbl + 0.5);
%         pause(0.5);
        [~,~,keyCode]=KbCheck;
        if any(keyCode(handles.parameters.keyCodes.down))  %%% charavail would be much better, but doesn't seem to work
            if any(keyCode(handles.parameters.keyCodes.shift))
                y=max(y-5,-handles.screenInfo.pix(2).*handles.gazeInfo.up);
            elseif any(keyCode(handles.parameters.keyCodes.zed))
                y=max(y-1,-handles.screenInfo.pix(2).*handles.gazeInfo.up);
            else
                y=max(y-50,-handles.screenInfo.pix(2).*handles.gazeInfo.up);
            end
        end
        if any(keyCode(handles.parameters.keyCodes.up))  %%% charavail would be much better, but doesn't seem to work
            if any(keyCode(handles.parameters.keyCodes.shift))
                y=min(y+5,handles.screenInfo.pix(2).*(1-handles.gazeInfo.up));
            elseif any(keyCode(handles.parameters.keyCodes.zed))
                y=min(y+1,handles.screenInfo.pix(2).*(1-handles.gazeInfo.up));
            else
                y=min(y+50,handles.screenInfo.pix(2).*(1-handles.gazeInfo.up));
            end
        end
        if any(keyCode(handles.parameters.keyCodes.left))  %%% charavail would be much better, but doesn't seem to work
            if any(keyCode(handles.parameters.keyCodes.shift))
                x=max(x-5,-handles.screenInfo.pix(1).*handles.gazeInfo.right);
            elseif any(keyCode(handles.parameters.keyCodes.zed))
                x=max(x-1,-handles.screenInfo.pix(1).*handles.gazeInfo.right);
            else
                x=max(x-50,-handles.screenInfo.pix(1).*handles.gazeInfo.right);
            end
        end
        if any(keyCode(handles.parameters.keyCodes.right))  %%% charavail would be much better, but doesn't seem to work
            if any(keyCode(handles.parameters.keyCodes.shift))
                x=min(x+5,handles.screenInfo.pix(1).*(1-handles.gazeInfo.right));
            elseif any(keyCode(handles.parameters.keyCodes.zed))
                x=min(x+1,handles.screenInfo.pix(1).*(1-handles.gazeInfo.right));
            else
                x=min(x+50,handles.screenInfo.pix(1).*(1-handles.gazeInfo.right));
            end
        end
        if any(keyCode(handles.parameters.keyCodes.one))
            radius=max(5,radius/2);
        end
        if any(keyCode(handles.parameters.keyCodes.two))
            radius=min(200,radius*2);
        end
        if any(keyCode(handles.parameters.keyCodes.escape))  %%% charavail would be much better, but doesn't seem to work
            find_hotspot=1;
        end
        
    end
%     Screen('DrawText',w,sprintf('Generating stimuli'),round(windowSize(3)/2)-50,round(windowSize(4)/2)-30);
%     Screen('Flip',w);
    Screen('Close',w);
    handles.stimulusInfo.rf.deg(1)=x;
    handles.stimulusInfo.rf.deg(2)=y;
    set(handles.rfUp,'String',num2str(y))
    set(handles.rfRight,'String',num2str(x))
    guidata(handles.output,handles) 
catch exception
    Screen('CloseAll')
    msgbox(['Program Failed: ',exception.message],'Error','error','modal')
end
 
    
function saveMovie_Callback(~, ~, ~)
    try
        [filename,filepath] = uiputfile('*.mat','Movie File','stimulusMovie');
        stimulusMovie=handles.stimulusInfo.movie.stimulus;
        save(fullfile(filepath,filename),'stimulusMovie');
        msgbox('Movie save complete','Success','modal')
    catch exception
        exception.message
        msgbox(['No movie saved: ',exception.message],'Error','error','modal')
    end    
function loadMovie_Callback(hObject, ~, handles)
    try
        [filename, filepath] = uigetfile('*.mat','Movie Matrix File','stimulusMovie.mat');
        handles.movie.file=fullfile(filepath,filename);
        set(movieLoaded,'String','movie loaded','ForeGroundColor','b');
        set(runMovie,'Value',1,'Enable','on');
    catch
    end
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 


    

 

function stimDuration_Callback(hObject, eventdata, handles)
    handles.stimulusInfo.widthUnits=get(handles.widthUnits,'Value');
    handles.stimulusInfo.speedUnits = get(handles.speedUnits,'Value');
    if isequal(get(handles.speedUnits,'Enable'),'on')
        switch handles.stimulusInfo.speedUnits
            case {1,2}
                set(handles.accelUnits,'Enable','on');
                set(handles.accelFirst,'Enable','on');
                set(handles.accelVary,'Enable','on');
            case 3
                set(handles.accelUnits,'Enable','off');
                set(handles.accelFirst,'String','0');
                set(handles.accelFirst,'Enable','off');
                set(handles.accelVary,'Value',1);
                set(handles.accelVary,'Enable','off');
                set(handles.accelRange,'String','acceleration undefined');
        end 
    end
    handles.stimulusInfo.accelUnits=get(handles.accelUnits,'Value');

    widthCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    speedCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    accelCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    stimType=handles.stimulusInfo.stimType;
    widthCallback(hObject,eventdata,handles);
    handles=guidata(handles.output);
    switch stimType
        case handles.guiInfo.gratingsIndices %gratings
            stimDuration=str2double(get(hObject,'String'));
            if isempty(stimDuration) || stimDuration<0
                stimDuration=3;
            end
            set(hObject,'String',num2str(stimDuration));
        otherwise % not gratings
            switch handles.stimulusInfo.speedUnits
                case 1
                    cps=handles.stimulusInfo.speeds(1);
                    switch handles.stimulusInfo.widthUnits
                        case 1
                            cpd=handles.stimulusInfo.widths(1);
                        case 2
                            cpd=0.5/handles.stimulusInfo.widths(1);
                    end
                    dps=cps/cpd;
                    stimDuration=handles.screenInfo.deg(1)/dps;
                    handles.screenInfo.deg(1);
                case 2
                    stimDuration=handles.screenInfo.deg(1)/handles.stimulusInfo.speeds(1);
                case 3
                    stimDuration=handles.stimulusInfo.speeds(1);
            end
            set(hObject,'String',num2str(stimDuration),'Enable','off')
    end
    handles.stimulusInfo.stimDuratoin=stimDuration;
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) 

function waitDuration_Callback(hObject, ~, handles)
    waitDuration=str2double(get(hObject,'String'));
    if isempty(waitDuration) || waitDuration<0
        waitDuration=0;
    end
    set(hObject,'String',num2str(waitDuration))
    handles.stimulusInfo.waitDuration=waitDuration;
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) ;
    
function checkDeg_Callback(hObject, ~, handles)
    checkDeg=str2double(get(hObject,'String'));
    if isempty(checkDeg) || checkDeg<0
        checkDeg=0;
    end
    set(hObject,'String',num2str(checkDeg))
    handles.stimulusInfo.checkDeg=checkDeg;
    handles.experimentInfo.rerun=0;
    guidata(handles.output,handles) ;


function movieScale_Callback(~, ~, handles)

function movieHz_Callback(~, ~, handles)


function runStimulus_Callback(~, eventdata, handles)
    
    stimType=handles.stimulusInfo.stimType;
    parameters={'orientations','widths','speeds','accelerations','contrasts','lengths','addWidths','addXs','addYs'};
    for p=1:length(parameters)
        eval([parameters{p},'=handles.stimulusInfo.(parameters{p});']);
        numberConditions(p)=length(handles.stimulusInfo.(parameters{p}));
    end
    if handles.stimulusInfo.speedUnits==3
        numberConditions(4)=1;
    end
    totalConditions=prod(numberConditions);

    parameters={'widthUnits','speedUnits','accelUnits','accelerations',...
        'adjustSpherically','waitDuration','checkDeg',...
        'randomOrder','addBlank','transverseBars','frameIndicator',...
        'checkeredFlicker'};
    for p=1:length(parameters)
        eval([parameters{p},'=handles.stimulusInfo.(parameters{p});']);
    end   
    recordImaging=handles.imagingInfo.record;
    pixelsX=handles.screenInfo.pix(1);
    pixelsY=handles.screenInfo.pix(2);
    screenHz=handles.screenInfo.Hz;
    screenDistance=handles.screenInfo.distance;
    degPathLength=handles.screenInfo.deg(1);
    TDT.sync=handles.stimulusInfo.TDT.sync;
    
    if ~handles.experimentInfo.rerun || ~handles.experimentInfo.texLoaded
        generateStimulusMovie(handles);
        handles=guidata(handles.output);
    end
    stimulusMovie=handles.stimulusInfo.movie.stimulus;
    stimDurations=handles.stimulusInfo.movie.durations;
    numFrames=handles.stimulusInfo.movie.numFrames;

    experimentNumber=handles.experimentInfo.experimentNumber;
    try
        if ~handles.experimentInfo.rerun || ~handles.experimentInfo.texLoaded
            Screen('Close'); % Closs all OFF screen windows and textures
            matchScreens(handles);
            w=handles.screenInfo.windowPtr;
            handles=guidata(handles.output);
            for c=1:totalConditions
                tex{c}=zeros(1,numFrames(c));
                for f=1:numFrames(c)
                    tex{c}(f)=Screen('MakeTexture',w,stimulusMovie{c}{f}');
                end
            end
%             try
%                 Screen('PreloadTextures');
%             end
            
        else
            tex=handles.experimentInfo.tex;
            w=handles.screenInfo.windowPtr;
        end
        
        intrinsicImaging=handles.imagingInfo.record;
        numberIters=handles.stimulusInfo.numberIters;
        numberTrials=handles.stimulusInfo.numberTrials;
        experimentalNotes=handles.stimulusInfo.experimentalNotes;
        datev=datevec(date);
        datedir='000000';
        if datev(2)<10
            datedir(2)=int2str(datev(2));
        else
            datedir(1:2)=int2str(datev(2));
        end
        if datev(3)<10
            datedir(4)=int2str(datev(3));
        else
            datedir(3:4)=int2str(datev(3));
        end
        datedir(5:6)=int2str(datev(1)-2000);

        if recordImaging

            saveVideo=handles.imagingInfo.saveVideo;
            exposure=handles.imagingInfo.exposure;
            fgi=handles.imagingInfo.fgi;
            handles.imagingInfo.frames=zeros(1,totalConditions);
            handles.imagingInfo.stimf=zeros(1,totalConditions);
            stoppreview(handles.vid);
            pause(0.5)
            stop(handles.vid);
            pause(0.5)
            flushdata(handles.vid);
            
            switch saveVideo
                case 1 %save full movie (across iterations) for each trial
                    startframes=zeros(1,numberIters);
                    handles.vid.LoggingMode='memory';
                case 2 
                    startframes=[];
                    handles.vid.LoggingMode='memory';
                case 3 
                    startframes=[];
                    handles.vid.LoggingMode='memory';
                case 4  % export to disk
                    startframes=zeros(1,numberIters);
                    handles.vid.LoggingMode='disk';
            end

            for c=1:totalConditions
                handles.imagingInfo.stimf(c)=1/stimDurations(c);
                switch saveVideo
                    case {1,4}  % save each iteration separately or save average for trial
                        handles.imagingInfo.frames(c)=ceil(numberIters*stimDurations(c)/exposure/fgi);
                    case 2  % save each iteration separately or save average for trial
                        handles.imagingInfo.frames(c)=ceil(stimDurations(c)/exposure/fgi);
                    case 3
                        handles.imagingInfo.frames(c)=ceil(stimDurations(c)/exposure/fgi);
                end
            end
            imagingFrames=handles.imagingInfo.frames;
            stimf=handles.imagingInfo.stimf;
            greenImage=handles.imagingInfo.greenImage;
            satcutoff=handles.imagingInfo.satcutoff;
            experimentFound=0;
            while ~experimentFound
                experimentFound=1;
                if isdir(fullfile('StimGen_Results',datedir,strcat('Experiment_',int2str(experimentNumber))))
                    replacebool=input(strcat('Experiment ',int2str(experimentNumber),' for date ',datedir,' already exists, do you wish to replace date in this folder? Enter ''Y'' or ''y'' for yes '),'s');
                    if ~isempty(replacebool)&&(all(replacebool=='Y')||all(replacebool=='y'))
                        rmdir(fullfile('StimGen_Results',datedir,strcat('Experiment_',int2str(experimentNumber))),'s')
                    else
                        experimentNumber=experimentNumber+1;
                        experimentFound=0;
                    end
                end
            end
            filebase=fullfile('StimGen_Results',datedir,strcat('Experiment_',int2str(experimentNumber)));
            mkdir(filebase)
            save(fullfile(filebase,strcat('imagingInfo_',datedir,'_',int2str(experimentNumber))),...
                'stimf','exposure','fgi','numberTrials','numberIters','numberConditions','imagingFrames','experimentalNotes','greenImage','datedir','experimentNumber','saveVideo','-v7.3')
            saveParams_Callback(handles.saveParams,eventdata,handles,fullfile(filebase,strcat('stimgenParams_',datedir,'_',int2str(experimentNumber))));
            for c=1:totalConditions
                mkdir(fullfile('StimGen_Results',datedir,strcat('Experiment_',int2str(experimentNumber)),strcat('Condition_',int2str(c))))
            end
        end

        vbl = Screen('Flip',w);
        conditionOrder=zeros(numberTrials,totalConditions);
        
        for trial=1:numberTrials
            conditionOrder(trial,:)=randperm(totalConditions);
             

            for c=conditionOrder(trial,:)
                c
                t=(1:numFrames(c))./handles.screenInfo.Hz;

                if recordImaging 
                    switch saveVideo
                        case 1
                            set(handles.vid,'FramesPerTrigger',handles.imagingInfo.frames(c));
                            startframes(:)=0;
                            start(handles.vid);
                        case 4
                            set(handles.vid,'FramesPerTrigger',handles.imagingInfo.frames(c));
                            startframes(:)=0;
                            logfile=fullfile(filebase,strcat('Condition_',int2str(c)),...
                                strcat('imagingLog_',datedir,'_',int2str(experimentNumber),...
                                '_c_',int2str(c),'_trial_',int2str(trial),'.avi'));
                            logger=VideoWriter(logfile,'Grayscale AVI');
                            handles.vid.DiskLogger=logger;
                            start(handles.vid);
                        case {2,3}
                            set(handles.vid,'FramesPerTrigger',handles.imagingInfo.frames(c));
                            if saveVideo==3
                                ISdata=zeros(handles.imagingInfo.framesize(1),handles.imagingInfo.framesize(2),handles.imagingInfo.frames(c));
                            end
                    end
                end
                for iter=1:numberIters
                    if recordImaging
                        switch saveVideo
                            case {1,4}
                                startframes(iter)=get(handles.vid,'FramesAcquired');
                            otherwise
                                disp(iter)
                                start(handles.vid);
                        end
                    end
                    for f=1:numFrames(c)
                        Screen('DrawTexture',w, tex{c}(f));
                        Screen('Flip',w, vbl + t(f));
                    end
                    if recordImaging && any(saveVideo==[2,3])
                        imaqsearch=0;
                        while isrunning(handles.vid)
                            pause(0.1)
                            imaqsearch=imaqsearch+1;
                            if imaqsearch==100
                                disp('viderr')
                                keyboard
                            end
                        end
                        if saveVideo==2
                            ISdata=squeeze(getdata(handles.vid));
                            save(fullfile(filebase,strcat('Condition_',int2str(c)),...
                                strcat('imagingData_',datedir,'_',int2str(experimentNumber),'_c_',int2str(c),'_trial_',int2str(trial),'_iter_',int2str(iter))),...
                                'ISdata','numberIters','-v7.3')
                        else
                            ISdata=ISdata+double(squeeze(getdata(handles.vid)));
                        end
                        %flushdata(handles.vid);
                    end

                end
                if recordImaging
                    switch saveVideo
                        case 1
                            imaqsearch=0;
                            while isrunning(handles.vid)
                                pause(0.1)
                                imaqsearch=imaqsearch+1;
                                if imaqsearch==100
                                    keyboard
                                end
                            end
                            ISdata=squeeze(getdata(handles.vid));
                            save(fullfile(filebase,strcat('Condition_',int2str(c)),...
                                strcat('imagingData_',datedir,'_',int2str(experimentNumber),'_c_',int2str(c),'_trial_',int2str(trial))),...
                                'ISdata','startframes','numberIters','-v7.3')
                            %flushdata(handles.vid);
                        case 4
                            imaqsearch=0;
                            while isrunning(handles.vid)
                                pause(0.1)
                                imaqsearch=imaqsearch+1;
                                if imaqsearch==100
                                    keyboard
                                end
                            end
                            imaqsearch=0;
                            while islogging(handles.vid)
                                pause(0.1)
                                imaqsearch=imaqsearch+1;
                                if imaqsearch==100
                                    keyboard
                                end
                            end
                            save(fullfile(filebase,strcat('Condition_',int2str(c)),...
                                strcat('imagingData_',datedir,'_',int2str(experimentNumber),'_c_',int2str(c),'_trial_',int2str(trial))),...
                                'logfile','startframes','numberIters','-v7.3')
                            %flushdata(handles.vid);
                        case 3
                            save(fullfile(filebase,strcat('Condition_',int2str(c)),...
                                strcat('imagingData_',datedir,'_',int2str(experimentNumber),'_c_',int2str(c),'_trial_',int2str(trial))),...
                                'ISdata','numberIters','-v7.3')
                    end
                end
            end
            
        end
        
        %Screen('CloseAll')
        
        
        if recordImaging        
            handles.imagingInfo.startframes=startframes;
            if saveVideo==1 || saveVideo==4
                analyzePhase2(datedir,experimentNumber,5);
            else
                analyzePhase2(datedir,experimentNumber,5);
            end
            handles.experimentInfo.experimentNumber=experimentNumber+1;
        end        
        handles.experimentInfo.rerun=1;
        handles.experimentInfo.texLoaded=1;
        handles.experimentInfo.tex=tex;
        guidata(handles.output,handles) ;
    catch exception
            Screen('CloseAll')
            movie.texLoaded=0;
            handles.experimentInfo.rerun=0;
            handles.stimulusInfo.movie=movie;
            guidata(handles.output,handles) ;
            exception.message
    end
    

function generateStimulusMovie(handles)
    hr=handles.stimulusInfo;
    hs=handles.screenInfo;
    parameters={'orientations','widths','speeds','accelerations','contrasts','lengths','addWidths','addXs','addYs'};
    for p=1:length(parameters)
        eval([parameters{p},'=hr.(parameters{p});']);
        numberConditions(p)=length(hr.(parameters{p}));
    end
    if hr.speedUnits==3
        numberConditions(4)=1;
    end
    totalConditions=prod(numberConditions);

    switch hr.stimType
        % convert widths speeds and accelerations to appropriate units
        case handles.guiInfo.gratingsIndices %gratings (width speeds and accelerations need to be in cyclesPerDeg and cyclesHz; speed and accelration are already forced to be so)
            if hr.widthUnits == 2 % width is in degPerCycle
                widths=1./widths; % 1/degreesPerCycle=cyclesPerDeg
            end %else widthUnits == 1 which means widths is already in cyclesPerDeg
        otherwise % not gratings (width speed and accelerations need to be in degPerBar and degHz)
            if hr.widthUnits == 1 % width is in cyclesPerDeg
                widths=0.5./widths; % cyclesPerBar/cyclesPerDegrees=degPerBar
            end % else widthUnits == 2 which means widths is already in degPerBar
            switch hr.speedUnits
                case 1 % cycles/sec
                    speeds=speeds./0.5*widths; % cyclesHz/cyclesPerBar*degPerBar=degHz
                case 3 % duration
                    speeds=hs.deg(1)./speeds;
                    accelerations=0;
            end % otherwise speedUnits==2 which means speeds is already in degHz
            if hr.speedUnits~=3 && hr.accelUnits==1 % acceleration is in cyclesHzHz
                accelerations=accelerations./0.5*widths; % cyclesHzHz/cyclesPerBar*degPerBar=degHzHz
            end % else speedUnits==2 which means speeds is already in degHzHz
    end
    
    % as fraction of screen
    [coordY,coordX]=...
        meshgrid(1:-1/hs.pix(2):1/hs.pix(2),...
                 1/hs.pix(1):1/hs.pix(1):1); 
    coordX=coordX*hs.cm(1)-handles.gazeInfo.cm(1); % in cm from gaze
    coordY=coordY*hs.cm(2)-handles.gazeInfo.cm(2); % in cm from gaze
    if handles.stimulusInfo.adjustSpherically
        Azimuth=atand(coordX./hs.distance); % degrees from gaze (tan = opposite/adjacent)
        Altitude=atand(coordY./sqrt(hs.distance.^2+coordX.^2));
    else
        Azimuth=coordX/hs.cm(1)*hs.deg(1); % in degrees 
        Altitude=coordY/hs.cm(2)*hs.deg(2); % in degrees 
    end
    stimEnds=repmat([min(Azimuth(:)),max(Azimuth(:))],[numberConditions(1)+1,1]); %last index reserved for copy of unoriented bounds
    for o=1:numberConditions(1)
        rotatedAzimuth{o}=(Azimuth.*cosd(orientations(o))-Altitude.*sind(orientations(o)));
        if hr.transverseBars
            stimEnds(o,:)=[min(rotatedAzimuth{o}(:)),max(rotatedAzimuth{o}(:))];
        end
        if hr.stimType==5 || hr.checkeredFlicker
            rotatedAltitude{o}=(Azimuth.*cosd(orientations(o)+90)-Altitude.*sind(orientations(o)+90));
        end
        if hr.checkeredFlicker
            checkerboardMask{o}=sign(sind(rotatedAzimuth{o}/hr.checkDeg*360)).*sign(sind(rotatedAltitude{o}/hr.checkDeg*360));
        end
    end

    whiteIndex = WhiteIndex(hs.num);
    blackIndex = BlackIndex(hs.num);
    intensityRange=whiteIndex-blackIndex;
    greyIndex = intensityRange/2 + blackIndex;
        
    for c=1:totalConditions
        [oInd,wInd,sInd,aInd,cInd,lInd,awInd,axInd,ayInd]=ind2sub(numberConditions,c);
        switch hr.stimType
            case handles.guiInfo.gratingsIndices %gratings 
                stimDurations(c)=hr.stimDuratoin;
            otherwise % not gratings
                if accelerations(aInd)==0
                    stimDurations(c)=hs.deg(1)/speeds(sInd);
                else
                    % distance=v*t+0.5a*t^2 ==> 
                    % by quadratic formula x=(-b+-sqrt(b^2-4ac))/(2a)
                    stimDurations(c)=(-speeds(sInd)+sqrt(speeds(sInd)^2+2*accelerations(aInd)*hs.deg(1)))/accelerations(aInd);
                end
        end

        numFrames(c)=ceil(stimDurations(c)*hs.Hz); % seconds*framesPerSec=frames
%         t=zeros(1,numFrames(c));
        t=(1:numFrames)./hs.Hz;

        switch hr.stimType
            case 1 % single Bar
                if hr.transverseBars && hr.speedUnits==3 % need to adjust speed to fully transverse screen in defined time
                    positionAtTime=stimEnds(oInd,1) + ...
                        t*speeds(sInd)*(abs(stimEnds(oInd,2)-stimEnds(oInd,1))/abs(stimEnds(end,2)-stimEnds(end,1)));
                else
                    positionAtTime=stimEnds(oInd,1) + t*speeds(sInd)+0.5*accelerations(aInd)*t.^2;%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                end
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=double(abs(rotatedAzimuth{oInd}-positionAtTime(f))<widths(wInd)/2);
                end                
            case 2 % double Bar
                if hr.transverseBars && hr.speedUnits==3 % need to adjust speed to fully transverse screen in defined time
                    positionAtTime=stimEnds(oInd,1) + ...
                        t*speeds(sInd)*(abs(stimEnds(oInd,2)-stimEnds(oInd,1))/abs(stimEnds(end,2)-stimEnds(end,1)));
                else
                    positionAtTime=stimEnds(oInd,1) + t*speeds(sInd)+0.5*accelerations(aInd)*t.^2;%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                end
                for f=1:numFrames(c)
                    tFrame=abs(rotatedAzimuth{oInd}-positionAtTime(f));
                    stimulusMovie{c}{f}=double(tFrame>widths(wInd)/2 & tFrame<3*widths(wInd)/2);
                end
            case 3 % sin-wave
                positionAtTime=t*speeds(sInd)+0.5*accelerations(aInd)*t.^2;%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=sind((rotatedAzimuth{oInd}*widths(wInd)+positionAtTime(f))*360);
                end
            case 4 % square-wave
                positionAtTime=t*speeds(sInd)+0.5*accelerations(aInd)*t.^2;%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=sign(sind((rotatedAzimuth{oInd}*widths(wInd)+positionAtTime(f))*360));
                end
            case 5 % checkerboard
                positionAtTime=t*speeds(sInd);%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                frame=sign(sind(rotatedAzimuth{oInd}*widths(wInd)*360)).*sign(sind(rotatedAltitude{oInd}*widths(wInd)*360));
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=sign(sind(positionAtTime(f)*360)).*frame;
                end
            case 6 % flicker
                positionAtTime=t*speeds(sInd);%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                frame=ones(size(rotatedAzimuth{oInd}));
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=sign(sind(positionAtTime(f)*360)).*frame;
                end
            case 7 % size-map
                positionAtTime=t*speeds(sInd)+0.5*accelerations(aInd)*t.^2;%max(gazeThetaCis(:))-t*speeds(sInd)-0.5*accelerations(aInd)*t.^2;
                for f=1:numFrames(c)
                    stimulusMovie{c}{f}=sind((rotatedAzimuth{oInd}*widths(wInd)+positionAtTime(f))*360);
                end
        end
        if hr.checkeredFlicker
            positionAtTime=t*3;
            for f=1:numFrames(c)
                stimulusMovie{c}{f}=stimulusMovie{c}{f}.*checkerboardMask{oInd}.*sign(sind(positionAtTime(f)*360));
            end
        end
        if any(hr.stimType==[1,2]) && ~hr.checkeredFlicker
            for f=1:numFrames(c)
                stimulusMovie{c}{f}=(stimulusMovie{c}{f}-0.5)*contrasts(cInd)*intensityRange+greyIndex;
                stimulusBackgroundColor=-0.5*contrast(cInd)*intensityRange+greyIndex;
            end
        else
            for f=1:numFrames(c)
                stimulusMovie{c}{f}=stimulusMovie{c}{f}/2*contrasts(cInd)*intensityRange+greyIndex;
                stimulusBackgroundColor=greyIndex;
            end
        end
        
        if lengths(lInd)~=0
            lengthMask=double(abs(sind(orientations(oInd)).*(Azimuth-Azimuth(round(gazeRight.*pixelsX)+rfRight,round(gazeUp.*pixelsY)+rfUp))...
                -cosd(orientations(oInd)).*(Altitude-Altitude(round(gazeRight.*pixelsX)+rfRight,round(gazeUp.*pixelsY)+rfUp)))...
                <lengths(lInd)/2);
            for f=1:numFrames(c)
                stimulusMovie{c}{f}(lengthMask)=stimulusBackgroundColor;
            end
        end  
        
        if hr.addType~=1
            switch hr.addType
                case 2 % envelope add ons
                    addMask=sqrt((Altitude-addXs(axInd)).^2+(Azimuth-addYs(ayInd)).^2)>addWidths(awInd);
                case 3 % occluder add ons
                    addMask=sqrt((Altitude-addXs(axInd)).^2+(Azimuth-addYs(ayInd)).^2)<addWidths(awInd);
            end
            for f=1:numFrames(c)
                stimulusMovie{c}{f}(addMask)=stimulusBackgroundColor;
            end
        end
    end
    handles.stimulusInfo.movie.stimulus=stimulusMovie;
    handles.stimulusInfo.movie.durations=stimDurations;
    handles.stimulusInfo.movie.numFrames=numFrames;
    guidata(handles.output,handles) ;

    


function experimentalNotes_Callback(hObject, eventdata, handles)
    handles.stimulusInfo.experimentalNotes=get(hObject,'string');
    guidata(handles.output,handles) ;
    
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
% Checkbox CallBacks
                function randomOrder_Callback(hObject, eventdata, handles)
                    handles.stimulusInfo.randomOrder=get(hObject,'Value');
                    guidata(handles.output,handles) ;
                function addBlank_Callback(hObject, ~, handles)
                    handles.stimulusInfo.addBlank=get(hObject,'Value');
                    guidata(handles.output,handles) ;
                function frameIndicator_Callback(hObject, ~, handles)
                    handles.stimulusInfo.frameIndicator=get(hObject,'Value');
                    handles.experimentInfo.rerun=0;
                    guidata(handles.output,handles) ;
                function adjustSpherically_Callback(hObject, ~, handles)
                    handles.stimulusInfo.adjustSpherically=get(hObject,'Value');
                    handles.experimentInfo.rerun=0;
                    guidata(handles.output,handles) ;   
                function transverseBars_Callback(hObject, ~, handles)
                    handles.stimulusInfo.transverseBars=get(hObject,'Value');
                    handles.experimentInfo.rerun=0;
                    guidata(handles.output,handles) ;
                function syncTDT_Callback(hObject, ~, handles)
                    handles.stimulusInfo.TDT.sync=get(hObject,'Value');
                    guidata(handles.output,handles) 
                function checkeredFlicker_Callback(hObject, ~, handles)
                    handles.stimulusInfo.checkeredFlicker=get(hObject,'Value');
                    handles.experimentInfo.rerun=0;
                    guidata(handles.output,handles) ;
                function intrinsicImaging_Callback(hObject, ~, handles)
                    handles.imagingInfo.record=get(hObject,'Value');
                    guidata(handles.output,handles) ;
                function runMovie_Callback(hObject, ~, handles)
                    handles.stimulusInfo.movie.run=get(hObject,'Value');
                    guidata(handles.output,handles)    
                function isEpisodic_Callback(hObject, eventdata, handles)
                    handles.imagingEpisodic=get(hObject,'Value');
                    guidata(handles.output,handles) 
% End of Checkbox Callbacks
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%                    
% Push Button Callbacks  
function saveParams_Callback(hObject, ~, handles,vargin)
    try
        if nargin==4
            fullpath=vargin;
        else
            [filename,filepath] = uiputfile('*.mat','Parameters File','stimulusParameters');
            fullpath=fullfile(filepath,filename);
        end
        for f=1:length(handles.guiInfo.popups)
            parameters.(handles.guiInfo.popups{f}).value=get(handles.(handles.guiInfo.popups{f}),'Value');
            parameters.(handles.guiInfo.popups{f}).enabled=get(handles.(handles.guiInfo.popups{f}),'Enable');
        end
        for f=1:length(handles.guiInfo.edits)
            parameters.(handles.guiInfo.edits{f}).value=get(handles.(handles.guiInfo.edits{f}),'String');
            parameters.(handles.guiInfo.edits{f}).enabled=get(handles.(handles.guiInfo.edits{f}),'Enable');
        end
        for f=1:length(handles.guiInfo.checkboxes)
            parameters.(handles.guiInfo.checkboxes{f}).value=get(handles.(handles.guiInfo.checkboxes{f}),'Value');
            parameters.(handles.guiInfo.checkboxes{f}).enabled=get(handles.(handles.guiInfo.checkboxes{f}),'Enable');
        end
        for f=1:length(handles.guiInfo.textdisplays)
            parameters.(handles.guiInfo.textdisplays{f}).value=get(handles.(handles.guiInfo.textdisplays{f}),'String');
            parameters.(handles.guiInfo.textdisplays{f}).enabled=get(handles.(handles.guiInfo.textdisplays{f}),'Enable');
        end
        save(fullpath,'parameters');
       % msgbox('Parameters save complete','Success','modal')
    catch exception
        msgbox(['No parameters saved: ',exception.message],'Error','error','modal')
    end    
    
function loadParams_Callback(hObject, eventdata, handles)
    try
        [filename, filepath] = uigetfile('*.mat','Parameters File','stimulusParameters.mat');
        load(fullfile(filepath,filename),'-regexp','parameters','movie')
        fields=fieldnames(stimulusInfo);
        handles.guiInfo=parameters;
        if exists(movie)
            handles.movie=movie;
        end    
        for f=1:length(handles.guiInfo.popups)
            handles.stimulusInfo.(handles.guiInfo.popups{f})=parameters.(handles.guiInfo.popups{f}).value;
            set(handles.(handles.guiInfo.popups{f}),'Value',parameters.(handles.guiInfo.popups{f}).value)
            set(handles.(handles.guiInfo.popups{f}),'Enable',parameters.(handles.guiInfo.popups{f}).enabled);
        end
        for f=1:length(handles.guiInfo.edits)
            handles.stimulusInfo.(handles.guiInfo.edits{f})=parameters.(handles.guiInfo.edits{f}).value;
            set(handles.(handles.guiInfo.edits{f}),'String',parameters.(handles.guiInfo.edits{f}).value)
            set(handles.(handles.guiInfo.edits{f}),'Enable',parameters.(handles.guiInfo.edits{f}).enabled);
        end
        for f=1:length(handles.guiInfo.checkboxes)
            handles.stimulusInfo.(handles.guiInfo.checkboxes{f})=parameters.(handles.guiInfo.checkboxes{f}).value;
            set(handles.(handles.guiInfo.checkboxes{f}),'Value',parameters.(handles.guiInfo.checkboxes{f}).value)
            set(handles.(handles.guiInfo.checkboxes{f}),'Enable',parameters.(handles.guiInfo.checkboxes{f}).enabled);
        end
        for f=1:length(handles.guiInfo.textdisplays)
            handles.stimulusInfo.(handles.guiInfo.textdisplays{f})=parameters.(handles.guiInfo.textdisplays{f}).value;
            set(handles.(handles.guiInfo.textdisplays{f}),'String',parameters.(handles.guiInfo.textdisplays{f}).value)
            set(handles.(handles.guiInfo.textdisplays{f}),'Enable',parameters.(handles.guiInfo.textdisplays{f}).enabled);
        end
        
        allCallbacks(hObject,eventdata,handles);
        handles=guidata(handles.output);
        msgbox('Parameters load complete','Success','modal')
    catch
        msgbox('Parameters failed to load fully','Error','error','modal')
    end
    
function startCamera_Callback(hObject, eventdata, handles)
    set(handles.intrinsicImaging,'Enable','on');
    set(handles.intrinsicImaging,'Value',1);
    intrinsicImaging_Callback(handles.intrinsicImaging,eventdata,handles);
    handles=guidata(handles.output);
    IntrinsicImagingGUI(hObject,handles);
    handles=guidata(handles.output);
    guidata(handles.output,handles) ;

function getKeyCodes_Callback(hObject, ~, handles)
    keys={'escape','up','right','down','left','shift','one','two','zed'};
    numberKeys=length(keys);
    h=waitbar(0,'Get ready to press requested keys...','WindowStyle','modal','CloseRequestFcn','');
    for k=1:numberKeys
        h=waitbar((k-1)/numberKeys,h,['Press ',keys{k},' key']);
        [secs, keyCode, deltaSecs]=KbWait;
        handles.parameters.keyCodes.(keys{k})=find(keyCode);
        h=waitbar((k-1)/numberKeys,h,['Release key.']);
        pause(2)
    end
    handles.parameters.keyCodes
    guidata(handles.output,handles) 

    delete(h);

    
% End Push Button Callbacks
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%


function result = vecangle(x1,y1,z1,x2,y2,z2)
if nargin<3
    z2=y1(3);
    z1=x1(3);
    y2=y1(2);
    x2=y1(1);
    y1=x1(2);
    x1=x1(1);
end
result=acosd((x1.*x2+y1.*y2+z1.*z2)./(sqrt(x1.^2+y1.^2+z1.^2).*sqrt(x2.^2+y2.^2+z2.^2)));


% --- Execute during corresponding object creation, after setting all properties.
% Presently not using any creation functions
function stimType_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function orientFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function orientVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function orientLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function orientNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function widthFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function widthVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function widthLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function widthNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function widthUnits_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function speedFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function speedVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function speedLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function speedNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function speedUnits_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function contrastFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function contrastVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function contrastLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function contrastNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenDist_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenHz_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenXpix_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenYpix_CreateFcn(hObject, ~, ~)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenXcm_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function screenYcm_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function gazeDown_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function gazeRight_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function gazeUp_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function rfUp_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function occludeUp_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function occludeRight_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function accelFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function accelVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function accelLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function accelNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function accelUnits_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function stimDuration_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function waitDuration_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function movieScale_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function movieHz_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function lengthFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function lengthVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function lengthLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function lengthNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Outputs from this function are returned to the command line.
function varargout = StimulusGenerator_OutputFcn(hObject, eventdata, handles) 
    % Get default command line output from handles structure
    varargout{1} = handles.output;
    stimType_Callback(handles.stimType, eventdata, handles);



function screenXdeg_Callback(hObject, ~, handles)
% hObject    handle to screenXdeg (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of screenXdeg as text
%        str2double(get(hObject,'String')) returns contents of screenXdeg as a double


% --- Executes during object creation, after setting all properties.
function screenXdeg_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function screenYdeg_Callback(hObject, ~, handles)
function screenYdeg_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end




function checkDeg_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end




function screenGamma_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function checkHz_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function numberTrials_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function setGaze_Callback(hObject, ~, handles)



function locationUp_Callback(hObject, ~, handles)

function locationUp_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function locationRight_Callback(hObject, ~, handles)
function locationRight_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function setGaze_CreateFcn(hObject, ~, handles)


function occludeUp_Callback(hObject, ~, handles)
function occludeRight_Callback(hObject, ~, handles)

function rfRight_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function gazeLocate_Callback(hObject, ~, handles)

function rfLocate_Callback(hObject, ~, handles)

function occludeLocate_Callback(hObject, ~, handles)

    
    
function addXFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addXVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addXLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addXNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addYFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addYVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addYLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addYNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addWidthFirst_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addWidthUnits_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addWidthVary_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addWidthLast_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function addWidthNum_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function numberIterations_CreateFcn(hObject, ~, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

function experimentalNotes_CreateFcn(hObject, eventdata, handles)
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end

% --- Executes during object deletion, before destroying properties.
function figure1_DeleteFcn(hObject, eventdata, handles)
    Screen('CloseAll');
    closereq;


function matchScreens(handles)
    openWindows=Screen('Windows');
    if ~isempty(handles.screenInfo.windowPtr) && ...
            length(openWindows)==1 && ...
            openWindows==handles.screenInfo.windowPtr && ...
            ~Screen(openWindows,'IsOffScreen') && ...
            Screen('WindowScreenNumber',openWindows)==handles.screenInfo.num
    else
        Screen('CloseAll')
        whiteIndex = WhiteIndex(handles.screenInfo.num);
        blackIndex = BlackIndex(handles.screenInfo.num);
        handles.screenInfo.greyIndex = (whiteIndex - blackIndex)/2 + blackIndex;
        handles.screenInfo.windowPtr=Screen('OpenWindow',handles.screenInfo.num,handles.screenInfo.greyIndex);
        WaitSecs(1);    
    end
    screenGamma=handles.screenInfo.gamma;
    flatClut = [(0:1/255:1)' (0:1/255:1)' (0:1/255:1)'];
    gammaClut = flatClut.^(1/screenGamma);
    Screen('LoadNormalizedGammaTable',handles.screenInfo.windowPtr,gammaClut);
    guidata(handles.output,handles) 



